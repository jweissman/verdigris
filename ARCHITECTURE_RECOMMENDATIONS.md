# Architecture Recommendations for Verdigris

## 1. PlayerControl Refactor

### Current Problems
- 796 lines of if/else chains
- Directly modifying unit.meta (breaks encapsulation)
- Managing cooldowns, state, and input all in one place
- Both translates to hero commands AND directly issues commands

### Proposed Solution: Simple Input Translator

```typescript
// PlayerControl should ONLY translate input to hero commands
class PlayerControl extends Rule {
  private inputQueue: InputEvent[] = [];
  
  execute(context: TickContext): QueuedCommand[] {
    const commands: QueuedCommand[] = [];
    
    // Find controlled units
    const heroes = context.getUnitsWithTag("hero");
    if (heroes.length === 0) return [];
    
    // Process each input event
    for (const event of this.inputQueue) {
      const heroCommand = this.translateInput(event);
      if (heroCommand) {
        commands.push({
          type: "hero",
          params: heroCommand
        });
      }
    }
    
    this.inputQueue = [];
    return commands;
  }
  
  private translateInput(event: InputEvent): HeroAction | null {
    switch (event.type) {
      case "keydown":
        return this.keyToAction(event.key);
      case "click":
        return { action: "move-to", x: event.x, y: event.y };
      case "rightclick":
        return { action: "attack-move", x: event.x, y: event.y };
    }
  }
  
  private keyToAction(key: string): HeroAction | null {
    const keyMap = {
      'w': { action: 'up' },
      's': { action: 'down' },
      'a': { action: 'left' },
      'd': { action: 'right' },
      ' ': { action: 'primary' },
      'q': { action: 'ability-1' },
      'e': { action: 'ability-2' },
      // etc
    };
    return keyMap[key] || null;
  }
}
```

## 2. HeroCommand Simplification

### Current Problems
- 562 lines doing too much
- Directly implementing abilities instead of delegating
- Generating particles (should be in renderer or effects system)
- Managing attack zones and other visual state

### Proposed Solution: Delegate to Ability Commands

```typescript
class HeroCommand extends Command {
  execute(unitId: string | null, params: CommandParams): void {
    const heroes = this.sim.getUnitsWithTag("hero");
    const action = params.action as string;
    
    for (const hero of heroes) {
      switch (action) {
        // Movement actions just set intendedMove
        case 'up':
        case 'down':
        case 'left':
        case 'right':
          this.queueMovement(hero, action);
          break;
          
        // Abilities delegate to their specific commands
        case 'strike':
          this.queueCommand('strike', hero.id, params);
          break;
        case 'bolt':
          this.queueCommand('bolt', hero.id, params);
          break;
        case 'jump':
          this.queueCommand('jump', hero.id, params);
          break;
        case 'dash':
          this.queueCommand('dash', hero.id, params);
          break;
        case 'blink':
          this.queueCommand('blink', hero.id, params);
          break;
          
        // Ability slots reference hero's equipped abilities
        case 'primary':
          const primaryAbility = hero.meta?.primaryAbility || 'strike';
          this.queueCommand(primaryAbility, hero.id, params);
          break;
      }
    }
  }
}
```

## 3. Separation of Concerns

### Rules Should Be In Sim
- **Gameplay logic** (damage, movement, status effects)
- **Game state** (unit positions, HP, teams)
- **Deterministic mechanics** (combat, physics)

### Rules Should NOT Be In Sim
- **Visual effects** (particles, animations, rigs)
- **Rendering state** (interpolation, camera, zoom)
- **Input handling** (beyond simple command translation)

### Move to Renderer
- `HeroAnimation` → Renderer reads rig state from units
- `ClearTeleportFlag` → Renderer manages its own interpolation
- Attack zones → Renderer reads from events/commands
- Particles → Generated by renderer based on events

## 4. Type Safety Improvements

### Current State
- 332 uses of `any` type
- Many implicit any from missing types
- Commands use `Record<string, any>` for params

### Recommendations

1. **Define specific param types for each command:**
```typescript
interface StrikeParams {
  targetId?: string;
  direction?: Direction;
  damage?: number;
  range?: number;
  knockback?: number;
}

class StrikeCommand extends Command<StrikeParams> {
  execute(unitId: string | null, params: StrikeParams): void {
    // Type-safe access to params
  }
}
```

2. **Replace any[] with specific types:**
```typescript
// Instead of
private rigData: Map<string, any[]> = new Map();

// Use
interface RigPart {
  sprite: string;
  offset: Vec2;
  rotation: number;
}
private rigData: Map<string, RigPart[]> = new Map();
```

3. **Type the TickContext properly:**
```typescript
// Instead of passing any
execute(context: TickContext): QueuedCommand[]

// Ensure TickContext has proper types
interface TickContext {
  getAllUnits(): Unit[];
  getCurrentTick(): number;
  getUnitsInRadius(center: Vec2, radius: number): Unit[];
  // etc
}
```

## 5. Command Pattern Consistency

### Current Issues
- Some commands modify units directly
- Some use Transform, some don't
- Inconsistent parameter handling

### Standardize Commands

All commands should:
1. Never modify units directly
2. Always use Transform for state changes
3. Return queued commands for side effects
4. Have typed parameters
5. Focus on a single responsibility

Example:
```typescript
class AoeCommand extends Command<AoeParams> {
  execute(unitId: string | null, params: AoeParams): void {
    // Validate params
    if (!this.validateParams(params)) return;
    
    // Find affected units
    const affected = this.findAffectedUnits(params);
    
    // Queue damage commands
    for (const unit of affected) {
      this.sim.queuedCommands.push({
        type: 'damage',
        params: {
          targetId: unit.id,
          amount: this.calculateDamage(unit, params),
          sourceId: unitId,
          aspect: params.type
        }
      });
    }
    
    // Queue event for visualization
    this.sim.queuedEvents.push({
      kind: 'aoe',
      source: unitId,
      target: { x: params.x, y: params.y },
      meta: {
        radius: params.radius,
        aspect: params.type,
        zones: this.generateZones(params)
      }
    });
  }
}
```

## 6. Performance Considerations

### Remove Expensive Rules from Sim
- Visual-only rules slow down simulation
- Sim should run headless for testing
- 30C4 synergy tests need speed

### Batch Operations
- Use pairwise batching for collision detection
- Cache frequently accessed data
- Avoid O(n²) operations where possible

## 7. Testing Strategy

### Unit Tests Should Test
- Individual commands in isolation
- Rule logic without full sim
- Type safety (no any escapes)

### Integration Tests Should Test
- Command chains
- Rule interactions
- Full game scenarios

### Visual Tests Should Be Separate
- Rendering logic
- Animation systems
- Particle effects

## Implementation Priority

1. **Immediate** (High impact, low effort)
   - Remove HeroAnimation from sim
   - Fix ground pound to use aoe ✅
   - Fix bolt/rock drop issues ✅

2. **Short term** (High impact, medium effort)
   - Refactor PlayerControl to simple translator
   - Type command parameters
   - Move visual rules to renderer

3. **Medium term** (Medium impact, high effort)
   - Eliminate most `any` types
   - Standardize all commands
   - Create proper event system

4. **Long term** (Architectural improvements)
   - Separate sim and render completely
   - Implement proper ECS
   - Performance optimization pass