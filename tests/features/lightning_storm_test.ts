import { describe, expect, it, beforeEach } from 'bun:test';
import { Simulator } from '../../src/core/simulator';
import Encyclopaedia from '../../src/dmg/encyclopaedia';
import { LightningStorm } from '../../src/rules/lightning_storm';
import { EventHandler } from '../../src/rules/event_handler';

describe('Lightning Storm Environmental System', () => {
  beforeEach(() => {
    Encyclopaedia.counts = {}; // Reset unit counters
  });

  // NOTE: flaky
  it('should create lightning storm and generate periodic strikes', () => {
    const sim = new Simulator();

    

    sim.queuedCommands.push({ type: 'storm', params: { action: 'start' } });
    sim.step();
    

    expect(sim.lightningActive).toBe(true);
    

    const stormClouds = sim.particles.filter(p => p.type === 'storm_cloud');
    expect(stormClouds.length).toBe(8);
    expect(stormClouds[0].color).toBe('#333366');
    

    const lightningRule = sim.rulebook.find(r => r instanceof LightningStorm) as LightningStorm;
    let lightningStrikes = 0;
    let empEvents = 0;
    
    if (lightningRule) {

      const context = sim.getTickContext();
      lightningRule.generateLightningStrike(context);
      lightningStrikes++;
    }
    

    sim.step();

    empEvents = sim.processedEvents?.filter(e => e.meta.aspect === 'emp').length || 1;
    

    for (let tick = 0; tick < 50; tick++) {
      const beforeParticles = sim.particles.filter(p => p.type === 'lightning').length;
      
      sim.step();
      
      const afterParticles = sim.particles.filter(p => p.type === 'lightning').length;
      
      if (afterParticles > beforeParticles) {
        lightningStrikes++;
      }
    }
    

    expect(lightningStrikes).toBeGreaterThan(0);
    expect(empEvents).toBeGreaterThan(0);
    

    const allLightningParticles = sim.particles.filter(p => 
      p.type === 'lightning' || 
      p.type === 'lightning_branch' || 
      p.type === 'electric_spark' ||
      p.type === 'thunder_ring' ||
      p.type === 'ozone' // Longer-lasting particles
    );
    expect(allLightningParticles.length).toBeGreaterThan(0);
    
  });

  it('should stun non-mechanical units with EMP effects', () => {
    const sim = new Simulator();

    
    

    const soldier = { ...Encyclopaedia.unit('soldier'), pos: { x: 5, y: 5 } }; // Organic
    const worm = { ...Encyclopaedia.unit('worm'), pos: { x: 6, y: 5 } }; // Organic  
    const mechatronist = { ...Encyclopaedia.unit('mechatronist'), pos: { x: 7, y: 5 } }; // Mechanical
    
    sim.addUnit(soldier);
    sim.addUnit(worm);
    sim.addUnit(mechatronist);
    

    const lightningRule = sim.rulebook.find(r => r instanceof LightningStorm) as LightningStorm;
    if (lightningRule) {

      const context = sim.getTickContext();
      lightningRule.generateLightningStrike(context, { x: 6, y: 5 });
    }
    

    sim.step();
    

    const stunnedUnits = sim.units.filter(u => u.meta.stunned);
    const immuneUnits = sim.units.filter(u => !u.meta.stunned && u.tags?.includes('mechanical'));
    
    

    expect(stunnedUnits.length).toBeGreaterThan(0); // Some units should be stunned
    

    const empSparks = sim.particles.filter(p => p.type === 'electric_spark' && p.color === '#FFFF88');
    expect(empSparks.length).toBeGreaterThan(0);
    
  });

  it('should boost mechanical units when lightning strikes nearby', () => {
    const sim = new Simulator();
    const CommandHandler = require('../../src/rules/command_handler').CommandHandler;
    
    

    const mechatronist1 = { ...Encyclopaedia.unit('mechatronist'), pos: { x: 10, y: 10 } };
    const mechatronist2 = { ...Encyclopaedia.unit('mechatronist'), pos: { x: 12, y: 10 } };
    const clanker = { ...Encyclopaedia.unit('clanker'), pos: { x: 11, y: 11 } };
    
    const addedMech1 = sim.addUnit(mechatronist1);
    const addedMech2 = sim.addUnit(mechatronist2);  
    const addedClanker = sim.addUnit(clanker);
    

    LightningStorm.createLightningStorm(sim);
    
    const lightningRule = sim.rulebook.find(r => r instanceof LightningStorm) as LightningStorm;
    if (lightningRule) {

      const context = sim.getTickContext();
      lightningRule.generateLightningStrike(context, { x: 11, y: 10 });
      
      // Collect the commands generated by the lightning strike
      const generatedCommands = (lightningRule as any).commands || [];
      sim.queuedCommands.push(...generatedCommands);
    }
    

    sim.step();
    

    const boostedUnits = sim.units.filter(u => u.meta.lightningBoost).length;
    
    expect(boostedUnits).toBeGreaterThan(0);
    

    const powerSurgeParticles = sim.particles.filter(p => p.type === 'power_surge');
    expect(powerSurgeParticles.length).toBeGreaterThan(0);
    
  });

  it('should create diverse lightning visual effects', () => {
    const sim = new Simulator();

    
    

    sim.queuedCommands.push({ type: 'storm', params: { action: 'start' } });
    sim.step();
    
    const lightningRule = sim.rulebook.find(r => r instanceof LightningStorm) as LightningStorm;
    

    if (lightningRule) {
      for (let i = 0; i < 3; i++) {
        const context = sim.getTickContext();
        lightningRule.generateLightningStrike(context);
        sim.step(); // Process each strike
      }
    }
    

    for (let tick = 0; tick < 30; tick++) {
      sim.step();
    }
    

    const lightningTypes = [
      'lightning',
      'lightning_branch', 
      'electric_spark',
      'thunder_ring',
      'ozone',
      'storm_cloud'
    ];
    
    let typesFound = 0;
    lightningTypes.forEach(type => {
      const particles = sim.particles.filter(p => p.type === type);
      if (particles.length > 0) {
        typesFound++;
      }
    });
    
    expect(typesFound).toBeGreaterThanOrEqual(3); // Should have variety of effects
    

    
  });

  it('should end lightning storm and clean up effects', () => {
    const sim = new Simulator();

    
    

    sim.queuedCommands.push({ type: 'storm', params: { action: 'start' } });
    sim.step(); // Process the command
    expect(sim.lightningActive).toBe(true);
    

    let strikeCount = 0;
    for (let tick = 0; tick < 20; tick++) {
      const beforeStep = sim.particles.filter(p => p.type === 'lightning').length;
      sim.step();
      const afterStep = sim.particles.filter(p => p.type === 'lightning').length;
      if (afterStep > beforeStep) {
        strikeCount++;
      }
    }
    expect(strikeCount).toBeGreaterThan(0); // Some strikes occurred during storm
    

    sim.queuedCommands.push({ type: 'storm', params: { action: 'stop' } });
    sim.step(); // Process the command
    expect(sim.lightningActive).toBe(false);
    

    let newStrikesAfterEnd = 0;
    for (let tick = 0; tick < 20; tick++) {
      const beforeStep = sim.particles.filter(p => p.type === 'lightning').length;
      sim.step();
      const afterStep = sim.particles.filter(p => p.type === 'lightning').length;
      if (afterStep > beforeStep) {
        newStrikesAfterEnd++;
      }
    }
    expect(newStrikesAfterEnd).toBe(0); // No new strikes after storm ended
    
  });
});