<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tracker</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #1a1a1a;
            color: #e0e0e0;
            font: 12px/1.4 'SF Mono', 'Monaco', 'Inconsolata', monospace;
            padding: 20px;
            overflow-x: auto;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        /* Header */
        .header {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }
        
        .header button {
            background: #2a2a2a;
            color: #e0e0e0;
            border: 1px solid #444;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.1s;
        }
        
        .header button:hover {
            background: #3a3a3a;
            border-color: #666;
        }
        
        .header button:active {
            background: #222;
        }
        
        .header button.active {
            background: #4a4a4a;
            border-color: #888;
        }
        
        .header input {
            background: #2a2a2a;
            color: #e0e0e0;
            border: 1px solid #444;
            padding: 4px 8px;
            width: 60px;
            font-size: 11px;
        }
        
        .header select {
            background: #2a2a2a;
            color: #e0e0e0;
            border: 1px solid #444;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
        }
        
        .tempo-group, .pattern-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .position {
            font-size: 14px;
            font-weight: bold;
            color: #888;
            min-width: 60px;
        }
        
        .position.playing {
            color: #4CAF50;
        }
        
        /* Pattern Grid */
        .grid-container {
            background: #222;
            border: 1px solid #444;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .grid {
            display: table;
            width: 100%;
            table-layout: fixed;
        }
        
        .grid-row {
            display: table-row;
        }
        
        .grid-row.header {
            background: #2a2a2a;
            border-bottom: 2px solid #444;
        }
        
        .grid-row.playing {
            background: rgba(76, 175, 80, 0.1);
        }
        
        .grid-row:nth-child(4n+2) {
            background: rgba(255, 255, 255, 0.02);
        }
        
        .cell {
            display: table-cell;
            padding: 4px;
            border-right: 1px solid #333;
            text-align: center;
            cursor: default;
            user-select: none;
            position: relative;
        }
        
        .cell.row-header {
            width: 40px;
            background: #2a2a2a;
            border-right: 2px solid #444;
            color: #666;
            font-size: 10px;
        }
        
        .cell.channel-header {
            padding: 8px 4px;
            font-weight: bold;
            background: #2a2a2a;
        }
        
        .cell.channel-header select {
            background: transparent;
            color: #e0e0e0;
            border: none;
            font-size: 10px;
            cursor: pointer;
            width: 100%;
        }
        
        .cell.note {
            cursor: text;
            color: #999;
            font-size: 11px;
            transition: background 0.1s;
        }
        
        .cell.note:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .cell.note.has-note {
            color: #e0e0e0;
        }
        
        .cell.note.selected {
            background: #3a3a4a;
            outline: 1px solid #666;
            outline-offset: -1px;
        }
        
        .cell.note.playing {
            background: rgba(76, 175, 80, 0.3);
            color: #fff;
        }
        
        .cell input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            color: #4CAF50;
            border: 1px solid #4CAF50;
            text-align: center;
            font: inherit;
            padding: 0;
            text-transform: uppercase;
        }
        
        /* Footer */
        .shortcuts {
            margin-top: 20px;
            padding: 10px;
            background: #2a2a2a;
            border-radius: 2px;
            font-size: 10px;
            color: #666;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .shortcuts span {
            white-space: nowrap;
        }
        
        .shortcuts kbd {
            background: #333;
            padding: 2px 4px;
            border-radius: 2px;
            color: #999;
            font-weight: bold;
        }
        
        /* Pattern bank */
        .pattern-bank {
            margin-top: 10px;
            display: flex;
            gap: 5px;
        }
        
        .pattern-slot {
            width: 30px;
            height: 30px;
            background: #2a2a2a;
            border: 1px solid #444;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.1s;
        }
        
        .pattern-slot:hover {
            background: #3a3a3a;
            border-color: #666;
        }
        
        .pattern-slot.active {
            background: #4a4a4a;
            border-color: #888;
            color: #4CAF50;
        }
        
        .pattern-slot.has-data {
            border-color: #4CAF50;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <button id="play">▶</button>
            <button id="stop">■</button>
            <div class="position" id="position">00:00</div>
            
            <div class="tempo-group">
                <label>BPM</label>
                <input type="number" id="bpm" value="120" min="60" max="200">
            </div>
            
            <div class="pattern-group">
                <label>Length</label>
                <select id="pattern-length">
                    <option value="16">16</option>
                    <option value="32">32</option>
                    <option value="64">64</option>
                </select>
            </div>
            
            <button id="clear">Clear</button>
            <button id="copy-pattern">Copy</button>
            <button id="paste-pattern">Paste</button>
        </div>
        
        <div class="grid-container">
            <div class="grid" id="grid"></div>
        </div>
        
        <div class="pattern-bank" id="pattern-bank"></div>
        
        <div class="shortcuts">
            <span><kbd>Space</kbd> Play/Stop</span>
            <span><kbd>↑↓←→</kbd> Navigate</span>
            <span><kbd>Enter</kbd> Edit</span>
            <span><kbd>Delete</kbd> Clear</span>
            <span><kbd>Ctrl+C/V</kbd> Copy/Paste</span>
            <span><kbd>Tab</kbd> Next</span>
            <span><kbd>1-8</kbd> Pattern Banks</span>
        </div>
    </div>
    
    <script type="module">
        // Clean, efficient tracker implementation
        class Synth {
            constructor() {
                this.audioContext = null;
                this.reverb = null;
                this.inversionState = {};
                this.bassStep = {};
            }
            
            init() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.setupReverb();
                }
            }
            
            setupReverb() {
                const length = this.audioContext.sampleRate * 1.5;
                const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }
                
                this.reverb = this.audioContext.createConvolver();
                this.reverb.buffer = impulse;
            }
            
            parseNote(note) {
                if (!note || note === '---' || note === '...') return null;
                
                // Check for chord
                const chordMatch = note.match(/^([A-G][#b]?)(m|maj7?|min7?|dim|aug|7|9)?$/);
                if (chordMatch) {
                    return this.parseChord(note);
                }
                
                // Single note with octave
                const noteMatch = note.match(/^([A-G][#b]?)(\d)$/);
                if (noteMatch) {
                    const [, noteName, octave] = noteMatch;
                    return this.noteToFreq(noteName, parseInt(octave));
                }
                
                return null;
            }
            
            noteToFreq(noteName, octave = 4) {
                const notes = {
                    'C': 261.63, 'C#': 277.18, 'Db': 277.18,
                    'D': 293.66, 'D#': 311.13, 'Eb': 311.13,
                    'E': 329.63,
                    'F': 349.23, 'F#': 369.99, 'Gb': 369.99,
                    'G': 392.00, 'G#': 415.30, 'Ab': 415.30,
                    'A': 440.00, 'A#': 466.16, 'Bb': 466.16,
                    'B': 493.88
                };
                
                const baseFreq = notes[noteName];
                if (!baseFreq) return null;
                
                return baseFreq * Math.pow(2, octave - 4);
            }
            
            parseChord(chord) {
                const intervals = {
                    '': [0, 4, 7],
                    'm': [0, 3, 7],
                    '7': [0, 4, 7, 10],
                    'maj7': [0, 4, 7, 11],
                    'm7': [0, 3, 7, 10],
                    'dim': [0, 3, 6],
                    'aug': [0, 4, 8],
                    '9': [0, 4, 7, 10, 14]
                };
                
                const match = chord.match(/^([A-G][#b]?)(m|maj7?|min7?|dim|aug|7|9)?$/);
                if (!match) return null;
                
                const [, root, quality = ''] = match;
                const chordIntervals = intervals[quality] || intervals[''];
                
                const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                let rootIndex = notes.indexOf(root.replace('b', ''));
                
                if (root.includes('b') && rootIndex > 0) {
                    rootIndex--;
                }
                
                const frequencies = [];
                for (const interval of chordIntervals) {
                    const noteIndex = (rootIndex + interval) % 12;
                    const freq = this.noteToFreq(notes[noteIndex], 4);
                    if (freq) frequencies.push(freq);
                }
                
                return frequencies;
            }
            
            play(voice, note, channel, duration = 0.2) {
                const freq = this.parseNote(note);
                if (!freq) return;
                
                if (!this.audioContext) this.init();
                
                switch(voice) {
                    case 'choir':
                        this.playChoir(freq, channel, duration);
                        break;
                    case 'bass':
                        this.playBass(freq, channel, duration);
                        break;
                    case 'pluck':
                        this.playPluck(freq, duration);
                        break;
                    case 'lead':
                        this.playLead(freq, duration);
                        break;
                    case 'pad':
                        this.playPad(freq, duration);
                        break;
                    default:
                        this.playSimple(freq, duration);
                }
            }
            
            playChoir(freq, channel, duration) {
                const now = this.audioContext.currentTime;
                const frequencies = Array.isArray(freq) ? freq : [freq];
                
                // Apply inversions
                if (!this.inversionState[channel]) this.inversionState[channel] = 0;
                
                if (frequencies.length > 1) {
                    const inv = this.inversionState[channel]++ % frequencies.length;
                    for (let i = 0; i < inv; i++) {
                        frequencies.push(frequencies.shift() * 2);
                    }
                }
                
                const gain = this.audioContext.createGain();
                const reverb = this.audioContext.createGain();
                
                frequencies.forEach((f, i) => {
                    for (let v = 0; v < 3; v++) {
                        const osc = this.audioContext.createOscillator();
                        const vGain = this.audioContext.createGain();
                        
                        osc.type = 'sine';
                        osc.frequency.value = f;
                        osc.detune.value = (v - 1) * 8;
                        
                        const level = 0.15 / Math.sqrt(frequencies.length);
                        vGain.gain.setValueAtTime(0, now);
                        vGain.gain.linearRampToValueAtTime(level, now + 0.1);
                        vGain.gain.exponentialRampToValueAtTime(0.01, now + duration);
                        
                        osc.connect(vGain);
                        vGain.connect(gain);
                        
                        osc.start(now + v * 0.01);
                        osc.stop(now + duration);
                    }
                });
                
                gain.connect(this.audioContext.destination);
                gain.connect(reverb);
                reverb.gain.value = 0.3;
                reverb.connect(this.reverb);
                this.reverb.connect(this.audioContext.destination);
            }
            
            playBass(freq, channel, duration) {
                const now = this.audioContext.currentTime;
                const frequencies = Array.isArray(freq) ? freq : [freq];
                
                if (!this.bassStep[channel]) this.bassStep[channel] = 0;
                
                // Walking bass pattern
                let bassFreq;
                if (frequencies.length > 1) {
                    const patterns = [[0, 2, 1, 0], [0, 1, 2, 1]];
                    const pattern = patterns[Math.floor(this.bassStep[channel] / 4) % patterns.length];
                    const idx = pattern[this.bassStep[channel]++ % 4];
                    bassFreq = frequencies[idx % frequencies.length] / 2;
                } else {
                    bassFreq = frequencies[0];
                }
                
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();
                
                osc.type = 'triangle';
                osc.frequency.value = bassFreq;
                
                filter.type = 'lowpass';
                filter.frequency.value = bassFreq * 3;
                filter.Q.value = 3;
                
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.4, now + 0.002);
                gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.audioContext.destination);
                
                osc.start(now);
                osc.stop(now + duration);
            }
            
            playPluck(freq, duration) {
                const now = this.audioContext.currentTime;
                const frequencies = Array.isArray(freq) ? freq : [freq];
                
                frequencies.forEach((f, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    const delay = i * 0.015;
                    
                    osc.type = 'triangle';
                    osc.frequency.value = f;
                    
                    const level = 0.3 / Math.sqrt(frequencies.length);
                    gain.gain.setValueAtTime(0, now + delay);
                    gain.gain.linearRampToValueAtTime(level, now + delay + 0.001);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + delay + duration);
                    
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.start(now + delay);
                    osc.stop(now + delay + duration);
                });
            }
            
            playLead(freq, duration) {
                const now = this.audioContext.currentTime;
                const leadFreq = Array.isArray(freq) ? freq[freq.length - 1] : freq;
                
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();
                
                osc.type = 'sawtooth';
                osc.frequency.value = leadFreq;
                
                filter.type = 'lowpass';
                filter.frequency.value = leadFreq * 6;
                filter.Q.value = 4;
                
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.25, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.audioContext.destination);
                
                osc.start(now);
                osc.stop(now + duration);
            }
            
            playPad(freq, duration) {
                const now = this.audioContext.currentTime;
                const frequencies = Array.isArray(freq) ? freq : [freq];
                
                const gain = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();
                
                filter.type = 'lowpass';
                filter.frequency.value = 2000;
                filter.Q.value = 1;
                
                frequencies.forEach(f => {
                    const osc = this.audioContext.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = f;
                    
                    osc.connect(filter);
                    osc.start(now);
                    osc.stop(now + duration + 0.5);
                });
                
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.1, now + 0.3);
                gain.gain.linearRampToValueAtTime(0.08, now + duration);
                gain.gain.exponentialRampToValueAtTime(0.01, now + duration + 0.5);
                
                filter.connect(gain);
                gain.connect(this.audioContext.destination);
            }
            
            playSimple(freq, duration) {
                const now = this.audioContext.currentTime;
                const frequencies = Array.isArray(freq) ? freq : [freq];
                
                frequencies.forEach(f => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.value = f;
                    
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
                    
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.start(now);
                    osc.stop(now + duration);
                });
            }
        }
        
        class Tracker {
            constructor() {
                this.synth = new Synth();
                this.channels = 4;
                this.steps = 16;
                this.patterns = {};
                this.currentPattern = 0;
                this.currentStep = 0;
                this.selectedCell = { channel: 0, step: 0 };
                this.isPlaying = false;
                this.bpm = 120;
                this.playbackTimer = null;
                this.clipboard = null;
                
                this.voices = ['choir', 'bass', 'pluck', 'lead'];
                this.channelVoices = [0, 1, 2, 3]; // Index into voices array
                
                this.init();
            }
            
            init() {
                this.initPattern(0);
                this.renderGrid();
                this.renderPatternBank();
                this.bindControls();
                this.bindKeyboard();
                
                // Load demo pattern
                this.patterns[0][0] = ['Am', '---', '---', '---', 'F', '---', '---', '---',
                                       'C', '---', '---', '---', 'G', '---', '---', '---'];
                this.patterns[0][1] = ['A2', '---', '---', '---', 'F2', '---', '---', '---',
                                       'C2', '---', '---', '---', 'G2', '---', '---', '---'];
                this.patterns[0][2] = ['---', '---', 'E4', '---', '---', '---', 'C4', '---',
                                       '---', '---', 'G4', '---', '---', '---', 'E4', '---'];
                this.renderGrid();
            }
            
            initPattern(index) {
                if (!this.patterns[index]) {
                    this.patterns[index] = [];
                    for (let ch = 0; ch < this.channels; ch++) {
                        this.patterns[index][ch] = [];
                        for (let s = 0; s < this.steps; s++) {
                            this.patterns[index][ch][s] = '---';
                        }
                    }
                }
            }
            
            renderGrid() {
                const grid = document.getElementById('grid');
                grid.innerHTML = '';
                
                // Header row
                const header = document.createElement('div');
                header.className = 'grid-row header';
                
                const corner = document.createElement('div');
                corner.className = 'cell row-header';
                header.appendChild(corner);
                
                for (let ch = 0; ch < this.channels; ch++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell channel-header';
                    
                    const select = document.createElement('select');
                    select.value = this.voices[this.channelVoices[ch]];
                    select.onchange = (e) => {
                        const voiceIndex = this.voices.indexOf(e.target.value);
                        if (voiceIndex >= 0) {
                            this.channelVoices[ch] = voiceIndex;
                        }
                    };
                    
                    for (const voice of this.voices) {
                        const option = document.createElement('option');
                        option.value = voice;
                        option.textContent = voice.toUpperCase();
                        if (voice === this.voices[this.channelVoices[ch]]) {
                            option.selected = true;
                        }
                        select.appendChild(option);
                    }
                    
                    cell.appendChild(select);
                    header.appendChild(cell);
                }
                
                grid.appendChild(header);
                
                // Pattern rows
                const pattern = this.patterns[this.currentPattern];
                
                for (let s = 0; s < this.steps; s++) {
                    const row = document.createElement('div');
                    row.className = 'grid-row';
                    row.id = `row-${s}`;
                    
                    const stepHeader = document.createElement('div');
                    stepHeader.className = 'cell row-header';
                    stepHeader.textContent = s.toString().padStart(2, '0');
                    row.appendChild(stepHeader);
                    
                    for (let ch = 0; ch < this.channels; ch++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell note';
                        cell.id = `cell-${ch}-${s}`;
                        cell.dataset.channel = ch;
                        cell.dataset.step = s;
                        
                        const value = pattern[ch][s];
                        cell.textContent = value;
                        
                        if (value !== '---') {
                            cell.classList.add('has-note');
                        }
                        
                        cell.onclick = () => this.selectCell(ch, s);
                        cell.ondblclick = () => this.editCell(ch, s);
                        
                        row.appendChild(cell);
                    }
                    
                    grid.appendChild(row);
                }
                
                this.updateSelection();
            }
            
            renderPatternBank() {
                const bank = document.getElementById('pattern-bank');
                bank.innerHTML = '';
                
                for (let i = 0; i < 8; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'pattern-slot';
                    slot.textContent = (i + 1).toString();
                    
                    if (i === this.currentPattern) {
                        slot.classList.add('active');
                    }
                    
                    if (this.patterns[i] && this.hasNotes(this.patterns[i])) {
                        slot.classList.add('has-data');
                    }
                    
                    slot.onclick = () => this.selectPattern(i);
                    bank.appendChild(slot);
                }
            }
            
            hasNotes(pattern) {
                for (let ch = 0; ch < this.channels; ch++) {
                    for (let s = 0; s < this.steps; s++) {
                        if (pattern[ch] && pattern[ch][s] !== '---') {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            selectPattern(index) {
                this.currentPattern = index;
                this.initPattern(index);
                this.renderGrid();
                this.renderPatternBank();
            }
            
            selectCell(channel, step) {
                this.selectedCell = { channel, step };
                this.updateSelection();
            }
            
            updateSelection() {
                document.querySelectorAll('.cell.note').forEach(cell => {
                    cell.classList.remove('selected');
                });
                
                const cell = document.getElementById(`cell-${this.selectedCell.channel}-${this.selectedCell.step}`);
                if (cell) {
                    cell.classList.add('selected');
                }
            }
            
            editCell(channel, step) {
                const cell = document.getElementById(`cell-${channel}-${step}`);
                if (!cell || cell.querySelector('input')) return;
                
                const currentValue = this.patterns[this.currentPattern][channel][step];
                
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentValue === '---' ? '' : currentValue;
                input.maxLength = 5;
                
                input.onblur = () => this.finishEdit(channel, step, input.value);
                input.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        this.finishEdit(channel, step, input.value);
                        this.moveSelection(0, 1);
                    } else if (e.key === 'Escape') {
                        this.finishEdit(channel, step, currentValue);
                    } else if (e.key === 'Tab') {
                        e.preventDefault();
                        this.finishEdit(channel, step, input.value);
                        this.moveSelection(e.shiftKey ? -1 : 1, 0);
                    }
                };
                
                cell.textContent = '';
                cell.appendChild(input);
                input.focus();
                input.select();
            }
            
            finishEdit(channel, step, value) {
                const cell = document.getElementById(`cell-${channel}-${step}`);
                if (!cell) return;
                
                const finalValue = value.trim().toUpperCase() || '---';
                this.patterns[this.currentPattern][channel][step] = finalValue;
                
                cell.textContent = finalValue;
                cell.classList.toggle('has-note', finalValue !== '---');
                
                // Preview sound
                if (finalValue !== '---') {
                    const voice = this.voices[this.channelVoices[channel]];
                    this.synth.play(voice, finalValue, channel, 0.2);
                }
            }
            
            moveSelection(dx, dy) {
                this.selectedCell.channel = Math.max(0, Math.min(this.channels - 1, 
                    this.selectedCell.channel + dx));
                this.selectedCell.step = Math.max(0, Math.min(this.steps - 1, 
                    this.selectedCell.step + dy));
                this.updateSelection();
            }
            
            bindControls() {
                document.getElementById('play').onclick = () => this.play();
                document.getElementById('stop').onclick = () => this.stop();
                document.getElementById('clear').onclick = () => this.clear();
                document.getElementById('copy-pattern').onclick = () => this.copyPattern();
                document.getElementById('paste-pattern').onclick = () => this.pastePattern();
                
                document.getElementById('bpm').onchange = (e) => {
                    this.bpm = parseInt(e.target.value) || 120;
                };
                
                document.getElementById('pattern-length').onchange = (e) => {
                    this.steps = parseInt(e.target.value) || 16;
                    this.initPattern(this.currentPattern);
                    this.renderGrid();
                };
            }
            
            bindKeyboard() {
                document.addEventListener('keydown', (e) => {
                    // Don't interfere with input fields
                    if (e.target.tagName === 'INPUT') return;
                    
                    switch(e.key) {
                        case ' ':
                            e.preventDefault();
                            this.isPlaying ? this.stop() : this.play();
                            break;
                        
                        case 'ArrowUp':
                            e.preventDefault();
                            this.moveSelection(0, -1);
                            break;
                        
                        case 'ArrowDown':
                            e.preventDefault();
                            this.moveSelection(0, 1);
                            break;
                        
                        case 'ArrowLeft':
                            e.preventDefault();
                            this.moveSelection(-1, 0);
                            break;
                        
                        case 'ArrowRight':
                            e.preventDefault();
                            this.moveSelection(1, 0);
                            break;
                        
                        case 'Enter':
                            e.preventDefault();
                            this.editCell(this.selectedCell.channel, this.selectedCell.step);
                            break;
                        
                        case 'Delete':
                        case 'Backspace':
                            e.preventDefault();
                            this.patterns[this.currentPattern][this.selectedCell.channel][this.selectedCell.step] = '---';
                            this.renderGrid();
                            break;
                        
                        case 'c':
                            if (e.ctrlKey || e.metaKey) {
                                e.preventDefault();
                                this.copyCell();
                            }
                            break;
                        
                        case 'v':
                            if (e.ctrlKey || e.metaKey) {
                                e.preventDefault();
                                this.pasteCell();
                            }
                            break;
                    }
                    
                    // Pattern bank shortcuts
                    if (e.key >= '1' && e.key <= '8') {
                        const index = parseInt(e.key) - 1;
                        this.selectPattern(index);
                    }
                });
            }
            
            copyCell() {
                this.clipboard = this.patterns[this.currentPattern][this.selectedCell.channel][this.selectedCell.step];
            }
            
            pasteCell() {
                if (this.clipboard) {
                    this.patterns[this.currentPattern][this.selectedCell.channel][this.selectedCell.step] = this.clipboard;
                    this.renderGrid();
                }
            }
            
            copyPattern() {
                this.clipboard = JSON.parse(JSON.stringify(this.patterns[this.currentPattern]));
            }
            
            pastePattern() {
                if (this.clipboard && Array.isArray(this.clipboard)) {
                    this.patterns[this.currentPattern] = JSON.parse(JSON.stringify(this.clipboard));
                    this.renderGrid();
                }
            }
            
            clear() {
                this.initPattern(this.currentPattern);
                this.patterns[this.currentPattern] = [];
                for (let ch = 0; ch < this.channels; ch++) {
                    this.patterns[this.currentPattern][ch] = [];
                    for (let s = 0; s < this.steps; s++) {
                        this.patterns[this.currentPattern][ch][s] = '---';
                    }
                }
                this.renderGrid();
            }
            
            play() {
                if (this.isPlaying) return;
                
                this.isPlaying = true;
                this.currentStep = 0;
                document.getElementById('play').classList.add('active');
                
                const stepTime = 60000 / (this.bpm * 4);
                
                const tick = () => {
                    if (!this.isPlaying) return;
                    
                    this.updatePlayback();
                    
                    const pattern = this.patterns[this.currentPattern];
                    for (let ch = 0; ch < this.channels; ch++) {
                        const note = pattern[ch][this.currentStep];
                        if (note && note !== '---') {
                            const voice = this.voices[this.channelVoices[ch]];
                            this.synth.play(voice, note, ch, stepTime / 1000 * 2);
                        }
                    }
                    
                    this.currentStep = (this.currentStep + 1) % this.steps;
                    this.playbackTimer = setTimeout(tick, stepTime);
                };
                
                tick();
            }
            
            stop() {
                this.isPlaying = false;
                if (this.playbackTimer) {
                    clearTimeout(this.playbackTimer);
                    this.playbackTimer = null;
                }
                
                document.getElementById('play').classList.remove('active');
                document.getElementById('position').classList.remove('playing');
                
                document.querySelectorAll('.grid-row').forEach(row => {
                    row.classList.remove('playing');
                });
                
                document.querySelectorAll('.cell.note').forEach(cell => {
                    cell.classList.remove('playing');
                });
            }
            
            updatePlayback() {
                // Update position display
                const pos = document.getElementById('position');
                const bar = Math.floor(this.currentStep / 4);
                const beat = this.currentStep % 4;
                pos.textContent = `${bar.toString().padStart(2, '0')}:${beat.toString().padStart(2, '0')}`;
                pos.classList.add('playing');
                
                // Update row highlight
                document.querySelectorAll('.grid-row').forEach(row => {
                    row.classList.remove('playing');
                });
                
                const currentRow = document.getElementById(`row-${this.currentStep}`);
                if (currentRow) {
                    currentRow.classList.add('playing');
                }
                
                // Update cell highlights
                document.querySelectorAll('.cell.note').forEach(cell => {
                    cell.classList.remove('playing');
                });
                
                for (let ch = 0; ch < this.channels; ch++) {
                    const cell = document.getElementById(`cell-${ch}-${this.currentStep}`);
                    if (cell) {
                        cell.classList.add('playing');
                    }
                }
            }
        }
        
        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            window.tracker = new Tracker();
        });
    </script>
</body>
</html>