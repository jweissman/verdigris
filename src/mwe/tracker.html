<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verdigris Tracker</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 10px;
            user-select: none;
        }
        
        .tracker {
            max-width: 600px;
            margin: 0 auto;
        }
        
        h1 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
        }
        
        .controls {
            margin-bottom: 10px;
            padding: 5px;
            border: 1px solid #0f0;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        button {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 2px 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
        }
        
        button:hover {
            background: #0f0;
            color: #000;
        }
        
        .pattern-grid {
            border: 1px solid #0f0;
            background: #000;
            display: table;
            width: 100%;
        }
        
        .track-headers {
            display: table-row;
            background: #001100;
        }
        
        .track-header {
            display: table-cell;
            padding: 4px;
            text-align: center;
            border-right: 1px solid #0f0;
            font-weight: bold;
            font-size: 10px;
            color: #0f0;
        }
        
        .pattern-row {
            display: table-row;
        }
        
        .pattern-row:nth-child(4n+1) {
            background: rgba(0, 255, 0, 0.05);
        }
        
        .pattern-row.playing {
            background: rgba(0, 255, 0, 0.2);
        }
        
        .step-num {
            display: table-cell;
            width: 25px;
            padding: 2px 4px;
            text-align: right;
            color: #006600;
            border-right: 2px solid #003300;
        }
        
        .note-cell {
            display: table-cell;
            padding: 1px 4px;
            border-right: 1px solid #001100;
            font-size: 10px;
            cursor: text;
            color: #aaa;
            width: 45px;
            height: 14px;
            position: relative;
        }
        
        .note-cell:hover {
            background: #002200;
        }
        
        .note-cell.active {
            background: #003300;
            color: #fff;
        }
        
        .note-cell.editing {
            background: #004400;
            color: #fff;
        }
        
        .note-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #002200;
            color: #0f0;
            border: 1px solid #0f0;
            font-family: inherit;
            font-size: 10px;
            padding: 0 2px;
            text-transform: uppercase;
        }
        
        input[type="text"] {
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 2px;
            font-family: inherit;
            font-size: 11px;
        }
        
        #bpm {
            width: 40px;
        }
        
        .status {
            color: #00ff00;
            margin-left: auto;
        }
        
        .info {
            margin-top: 10px;
            padding: 5px;
            border: 1px solid #003300;
            font-size: 10px;
            color: #008800;
        }
    </style>
</head>
<body>
    <div class="tracker">
        <h1>VERDIGRIS TRACKER v0.2</h1>
        
        <div class="controls">
            <button id="play">▶ PLAY</button>
            <button id="stop">■ STOP</button>
            <button id="clear">CLEAR</button>
            <select id="song-select">
                <option value="">-- Load Song --</option>
                <option value="the-lich">The Lich</option>
            </select>
            <button id="load-song">LOAD</button>
            <label>BPM: <input type="range" id="bpm" min="60" max="200" value="120"><span id="bpm-display">120</span></label>
            <div class="status" id="status">READY</div>
        </div>

        <div class="fx-panel" style="border: 1px solid #0f0; padding: 10px; margin: 10px 0;">
            <h3 style="color: #0f0; font-size: 12px; margin-bottom: 5px;">FX CONTROLS</h3>
            <div style="display: flex; gap: 15px; align-items: center;">
                <label style="font-size: 10px;">REVERB: <input type="range" id="reverb" min="0" max="100" value="20"></label>
                <label style="font-size: 10px;">FILTER: <input type="range" id="filter" min="100" max="8000" value="4000"></label>
                <label style="font-size: 10px;">DISTORT: <input type="range" id="distortion" min="0" max="100" value="0"></label>
                <button id="combat-mode" style="background: #000; color: #f80; border: 1px solid #f80;">COMBAT MODE</button>
            </div>
        </div>
        
        <div class="pattern-grid" id="grid">
            <!-- Grid will be generated here -->
        </div>
        
        <div class="info">
            Click cells to edit. Use note names (C4, D#3), chord symbols (Am, G7, C#maj7) or --- for rest. 
            Tab/Enter to move. Space to play/stop. Choir plays full chords, other voices adapt.
        </div>
    </div>
    
    <script type="module">
        // Improved synthesis with proper voice characteristics
        class ImprovedSynth {
            constructor() {
                this.audioContext = null;
                this.reverb = null;
                this.chordInversion = 0; // Track inversion state
                this.bassPattern = 0; // Track bass pattern position
            }
            
            init() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.setupReverb();
                }
            }
            
            setupReverb() {
                // Simple reverb using convolver
                const length = this.audioContext.sampleRate * 2;
                const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }
                
                this.reverb = this.audioContext.createConvolver();
                this.reverb.buffer = impulse;
            }
            
            playChoir(freq, duration) {
                if (!this.audioContext) this.init();
                
                const now = this.audioContext.currentTime;
                const gainNode = this.audioContext.createGain();
                const reverbSend = this.audioContext.createGain();
                
                // Handle chord (array of frequencies)
                let frequencies = Array.isArray(freq) ? freq : [freq];
                
                // Apply inversion cycling for chords
                if (frequencies.length > 1) {
                    // Rotate notes based on current inversion
                    const inversionAmount = this.chordInversion % frequencies.length;
                    for (let i = 0; i < inversionAmount; i++) {
                        // Move lowest note up an octave
                        const lowest = frequencies.shift();
                        frequencies.push(lowest * 2);
                    }
                    // Increment for next chord
                    this.chordInversion++;
                }
                
                // Voice configuration for ensemble
                const voiceConfigs = [
                    { detune: 0, pan: 0, delay: 0 },
                    { detune: 8, pan: -0.3, delay: 0.01 },
                    { detune: -7, pan: 0.3, delay: 0.015 }
                ];
                
                // Play each note in the chord
                frequencies.forEach((noteFreq, noteIndex) => {
                    // Spread chord notes across stereo field
                    const basePan = (noteIndex - frequencies.length / 2) * 0.3;
                    
                    // Create multiple detuned voices per note for richness
                    voiceConfigs.forEach(voice => {
                        const osc = this.audioContext.createOscillator();
                        const voiceGain = this.audioContext.createGain();
                        const panner = this.audioContext.createStereoPanner();
                        
                        osc.type = 'sine';
                        osc.frequency.value = noteFreq;
                        osc.detune.value = voice.detune;
                        
                        // Add vibrato
                        const vibrato = this.audioContext.createOscillator();
                        const vibratoGain = this.audioContext.createGain();
                        vibrato.frequency.value = 4.5; // Hz
                        vibratoGain.gain.value = noteFreq * 0.02; // 2% depth
                        vibrato.connect(vibratoGain);
                        vibratoGain.connect(osc.frequency);
                        vibrato.start(now + voice.delay);
                        
                        // Slow envelope for choir
                        const gainPerVoice = 0.15 / Math.sqrt(frequencies.length); // Scale down for chords
                        voiceGain.gain.setValueAtTime(0, now + voice.delay);
                        voiceGain.gain.linearRampToValueAtTime(gainPerVoice, now + voice.delay + 0.15);
                        voiceGain.gain.linearRampToValueAtTime(gainPerVoice * 0.8, now + voice.delay + 0.35);
                        voiceGain.gain.exponentialRampToValueAtTime(0.01, now + voice.delay + duration);
                        
                        panner.pan.value = Math.max(-1, Math.min(1, basePan + voice.pan));
                        
                        osc.connect(voiceGain);
                        voiceGain.connect(panner);
                        panner.connect(gainNode);
                        
                        osc.start(now + voice.delay);
                        osc.stop(now + voice.delay + duration);
                        vibrato.stop(now + voice.delay + duration);
                    });
                });
                
                // Add reverb
                reverbSend.gain.value = 0.35;
                gainNode.connect(this.audioContext.destination);
                gainNode.connect(reverbSend);
                reverbSend.connect(this.reverb);
                this.reverb.connect(this.audioContext.destination);
            }
            
            playBass(freq, duration) {
                if (!this.audioContext) this.init();
                
                const now = this.audioContext.currentTime;
                
                // For bass, walk through chord tones
                if (Array.isArray(freq) && freq.length > 1) {
                    // Walking bass pattern: 1-3-5-octave or 1-5-3-7 etc
                    const patterns = [
                        [0, 1, 2, 0], // 1-3-5-1
                        [0, 2, 1, 0], // 1-5-3-1
                        [0, 1, 0, 2], // 1-3-1-5
                        [0, 2, 0, 1]  // 1-5-1-3
                    ];
                    
                    const pattern = patterns[Math.floor(this.bassPattern / 4) % patterns.length];
                    const noteIndex = pattern[this.bassPattern % 4];
                    const baseFreq = freq[noteIndex % freq.length] / 2; // Drop an octave for bass
                    
                    this.bassPattern++;
                    
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    osc.type = 'triangle';
                    osc.frequency.value = baseFreq;
                    
                    // Low-pass filter for bass
                    filter.type = 'lowpass';
                    filter.frequency.value = baseFreq * 4;
                    filter.Q.value = 2;
                    
                    // Punchy envelope
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.5, now + 0.002);
                    gain.gain.exponentialRampToValueAtTime(0.1, now + 0.3);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
                    
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.start(now);
                    osc.stop(now + duration);
                } else {
                    // Single note
                    const baseFreq = Array.isArray(freq) ? freq[0] : freq;
                    
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    osc.type = 'triangle';
                    osc.frequency.value = baseFreq;
                    
                    // Low-pass filter for bass
                    filter.type = 'lowpass';
                    filter.frequency.value = baseFreq * 4;
                    filter.Q.value = 2;
                    
                    // Punchy envelope
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.5, now + 0.002);
                    gain.gain.exponentialRampToValueAtTime(0.1, now + 0.3);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
                    
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.start(now);
                    osc.stop(now + duration);
                }
            }
            
            playPluck(freq, duration) {
                if (!this.audioContext) this.init();
                
                const now = this.audioContext.currentTime;
                
                // For pluck, arpeggiate chords quickly
                const frequencies = Array.isArray(freq) ? freq : [freq];
                const arpDelay = 0.02; // 20ms between notes
                
                frequencies.forEach((noteFreq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    const startTime = now + (i * arpDelay);
                    
                    // Use sine with slight detuning for pluck
                    osc.type = 'sine';
                    osc.frequency.value = noteFreq;
                    
                    // Very fast attack, natural decay
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(0.4 / Math.sqrt(frequencies.length), startTime + 0.001);
                    gain.gain.exponentialRampToValueAtTime(0.1 / Math.sqrt(frequencies.length), startTime + 0.5);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
                    
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.start(startTime);
                    osc.stop(startTime + duration);
                });
            }
            
            playLead(freq, duration) {
                if (!this.audioContext) this.init();
                
                // For lead, play highest note of chord (melody)
                const leadFreq = Array.isArray(freq) ? freq[freq.length - 1] : freq;
                
                const now = this.audioContext.currentTime;
                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();
                
                osc.type = 'sawtooth';
                osc.frequency.value = leadFreq;
                
                // Resonant filter for brightness
                filter.type = 'lowpass';
                filter.frequency.value = leadFreq * 8;
                filter.Q.value = 5;
                
                // Quick attack, sustained
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.3, now + 0.01);
                gain.gain.linearRampToValueAtTime(0.25, now + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, now + duration);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.audioContext.destination);
                
                osc.start(now);
                osc.stop(now + duration);
            }
            
            parseChord(chord) {
                // Parse chord symbols like C#m, Amaj7, Bb7, Gdim
                const match = chord.match(/^([A-G][#b]?)(m|maj7?|min7?|dim|aug|sus[24]|7|9|11|13)?(\/([A-G][#b]?))?$/);
                if (!match) return null;
                
                const [, root, quality = '', , bassNote] = match;
                const intervals = {
                    '': [0, 4, 7],           // Major
                    'm': [0, 3, 7],          // Minor  
                    'min': [0, 3, 7],        // Minor alt
                    '7': [0, 4, 7, 10],      // Dominant 7th
                    'maj7': [0, 4, 7, 11],   // Major 7th
                    'min7': [0, 3, 7, 10],   // Minor 7th
                    'm7': [0, 3, 7, 10],     // Minor 7th alt
                    'dim': [0, 3, 6],        // Diminished
                    'aug': [0, 4, 8],        // Augmented
                    'sus2': [0, 2, 7],       // Suspended 2nd
                    'sus4': [0, 5, 7],       // Suspended 4th
                    '9': [0, 4, 7, 10, 14],  // 9th
                    '11': [0, 4, 7, 10, 17], // 11th
                    '13': [0, 4, 7, 10, 21]  // 13th
                };
                
                const chordIntervals = intervals[quality] || intervals[''];
                const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                
                // Handle flats
                let rootNote = root.replace('b', '');
                let rootIndex = notes.indexOf(rootNote);
                if (root.includes('b') && rootIndex > 0) {
                    rootIndex--;
                }
                
                const chordNotes = [];
                for (const interval of chordIntervals) {
                    const noteIndex = (rootIndex + interval) % 12;
                    chordNotes.push(notes[noteIndex]);
                }
                
                // Handle slash chords (specific bass note)
                if (bassNote) {
                    let bassNoteClean = bassNote.replace('b', '');
                    let bassIndex = notes.indexOf(bassNoteClean);
                    if (bassNote.includes('b') && bassIndex > 0) {
                        bassIndex--;
                    }
                    // Put bass note first
                    const bassNoteName = notes[bassIndex];
                    chordNotes.unshift(bassNoteName);
                }
                
                return chordNotes;
            }
            
            noteToFreq(note) {
                if (!note || note === '---' || note === '...') return null;
                
                const notes = { 
                    'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13,
                    'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00,
                    'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88
                };
                
                // Check if it's a chord
                const chordNotes = this.parseChord(note);
                if (chordNotes) {
                    // Return array of frequencies for chord
                    return chordNotes.map(n => notes[n]);
                }
                
                // Single note
                const match = note.toUpperCase().match(/([A-G]#?)(\d)/);
                if (!match) return null;
                
                const [, noteName, octave] = match;
                const baseFreq = notes[noteName];
                if (!baseFreq) return null;
                
                const octaveShift = parseInt(octave) - 4;
                return baseFreq * Math.pow(2, octaveShift);
            }
        }
        
        // Tracker UI with vertical layout
        class TrackerUI {
            constructor() {
                this.synth = new ImprovedSynth();
                this.pattern = [];
                this.steps = 16;
                this.channels = 4;
                this.channelNames = ['CHOIR', 'BASS', 'PLUCK', 'LEAD'];
                this.currentStep = 0;
                this.isPlaying = false;
                this.bpm = 120;
                this.timer = null;
                this.editingCell = null;
                
                this.initPattern();
                this.initUI();
                this.setupKeyboardShortcuts();
            }
            
            initPattern() {
                this.pattern = [];
                for (let ch = 0; ch < this.channels; ch++) {
                    this.pattern[ch] = [];
                    for (let step = 0; step < this.steps; step++) {
                        this.pattern[ch][step] = '---';
                    }
                }
                
                // Demo pattern with chords - will cycle through inversions!
                this.pattern[0] = ['Gm', '---', 'Bb', '---', 'Dm', '---', 'F', '---',
                                   'Gm', '---', 'Eb', '---', 'Dm', '---', 'Gm', '---'];
                this.pattern[1] = ['G2', '---', '---', '---', 'D2', '---', '---', '---',
                                   'E2', '---', '---', '---', 'C2', '---', '---', '---'];
            }
            
            initUI() {
                this.renderGrid();
                
                document.getElementById('play').onclick = () => this.play();
                document.getElementById('stop').onclick = () => this.stop();
                document.getElementById('clear').onclick = () => this.clear();
                document.getElementById('bpm').onchange = (e) => {
                    this.bpm = parseInt(e.target.value) || 120;
                };
            }
            
            renderGrid() {
                const grid = document.getElementById('grid');
                grid.innerHTML = '';
                
                // Track headers
                const headerRow = document.createElement('div');
                headerRow.className = 'track-headers';
                
                const cornerCell = document.createElement('div');
                cornerCell.className = 'track-header';
                cornerCell.style.width = '25px';
                cornerCell.textContent = '#';
                headerRow.appendChild(cornerCell);
                
                for (let ch = 0; ch < this.channels; ch++) {
                    const header = document.createElement('div');
                    header.className = 'track-header';
                    header.textContent = this.channelNames[ch];
                    headerRow.appendChild(header);
                }
                
                grid.appendChild(headerRow);
                
                // Pattern rows
                for (let step = 0; step < this.steps; step++) {
                    const row = document.createElement('div');
                    row.className = 'pattern-row';
                    row.id = `row-${step}`;
                    
                    // Step number
                    const stepNum = document.createElement('div');
                    stepNum.className = 'step-num';
                    stepNum.textContent = step.toString().padStart(2, '0');
                    row.appendChild(stepNum);
                    
                    // Note cells for each channel
                    for (let ch = 0; ch < this.channels; ch++) {
                        const cell = document.createElement('div');
                        cell.className = 'note-cell';
                        cell.id = `cell-${ch}-${step}`;
                        cell.textContent = this.pattern[ch][step];
                        cell.dataset.channel = ch;
                        cell.dataset.step = step;
                        
                        cell.onclick = (e) => this.startEdit(ch, step, e.target);
                        
                        row.appendChild(cell);
                    }
                    
                    grid.appendChild(row);
                }
            }
            
            startEdit(channel, step, cell) {
                // Remove any existing input
                if (this.editingCell) {
                    this.finishEdit();
                }
                
                this.editingCell = { channel, step, cell };
                cell.classList.add('editing');
                
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'note-input';
                input.value = this.pattern[channel][step];
                input.maxLength = 3;
                
                input.onblur = () => this.finishEdit();
                input.onkeydown = (e) => this.handleEditKey(e);
                
                cell.textContent = '';
                cell.appendChild(input);
                input.focus();
                input.select();
            }
            
            handleEditKey(e) {
                if (e.key === 'Enter' || e.key === 'Tab') {
                    e.preventDefault();
                    this.finishEdit();
                    
                    // Move to next cell
                    if (e.key === 'Tab') {
                        const nextChannel = (this.editingCell.channel + 1) % this.channels;
                        const nextStep = nextChannel === 0 ? 
                            (this.editingCell.step + 1) % this.steps : 
                            this.editingCell.step;
                        
                        const nextCell = document.getElementById(`cell-${nextChannel}-${nextStep}`);
                        if (nextCell) {
                            this.startEdit(nextChannel, nextStep, nextCell);
                        }
                    }
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    const input = e.target;
                    input.value = this.pattern[this.editingCell.channel][this.editingCell.step];
                    this.finishEdit();
                }
            }
            
            finishEdit() {
                if (!this.editingCell) return;
                
                const input = this.editingCell.cell.querySelector('input');
                if (input) {
                    const value = input.value.trim().toUpperCase() || '---';
                    this.pattern[this.editingCell.channel][this.editingCell.step] = value;
                    
                    // Preview the note
                    const freq = this.synth.noteToFreq(value);
                    if (freq) {
                        this.playChannelNote(this.editingCell.channel, freq, 0.2);
                    }
                }
                
                this.editingCell.cell.classList.remove('editing');
                this.editingCell.cell.textContent = this.pattern[this.editingCell.channel][this.editingCell.step];
                this.editingCell = null;
            }
            
            playChannelNote(channel, freq, duration) {
                switch(channel) {
                    case 0: this.synth.playChoir(freq, duration); break;
                    case 1: this.synth.playBass(freq, duration); break;
                    case 2: this.synth.playPluck(freq, duration); break;
                    case 3: this.synth.playLead(freq, duration); break;
                }
            }
            
            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (this.editingCell) return; // Don't interfere with editing
                    
                    if (e.code === 'Space') {
                        e.preventDefault();
                        if (this.isPlaying) {
                            this.stop();
                        } else {
                            this.play();
                        }
                    }
                });
            }
            
            play() {
                if (this.isPlaying) return;
                
                this.isPlaying = true;
                this.currentStep = 0;
                document.getElementById('status').textContent = 'PLAYING';
                
                const stepTime = 60000 / (this.bpm * 4); // 16th notes
                
                const tick = () => {
                    if (!this.isPlaying) return;
                    
                    // Update display
                    this.updateDisplay();
                    
                    // Play notes at current step
                    for (let ch = 0; ch < this.channels; ch++) {
                        const note = this.pattern[ch][this.currentStep];
                        const freq = this.synth.noteToFreq(note);
                        if (freq) {
                            this.playChannelNote(ch, freq, stepTime / 1000 * 2);
                        }
                    }
                    
                    // Next step
                    this.currentStep = (this.currentStep + 1) % this.steps;
                    
                    this.timer = setTimeout(tick, stepTime);
                };
                
                tick();
            }
            
            stop() {
                this.isPlaying = false;
                if (this.timer) {
                    clearTimeout(this.timer);
                    this.timer = null;
                }
                document.getElementById('status').textContent = 'STOPPED';
                this.clearDisplay();
            }
            
            clear() {
                this.stop();
                this.initPattern();
                this.renderGrid();
                document.getElementById('status').textContent = 'CLEARED';
            }
            
            updateDisplay() {
                // Clear previous
                document.querySelectorAll('.pattern-row').forEach(row => {
                    row.classList.remove('playing');
                });
                
                // Highlight current row
                const currentRow = document.getElementById(`row-${this.currentStep}`);
                if (currentRow) {
                    currentRow.classList.add('playing');
                }
            }
            
            clearDisplay() {
                document.querySelectorAll('.pattern-row').forEach(row => {
                    row.classList.remove('playing');
                });
            }
        }
        
        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            window.tracker = new TrackerUI();
        });
    </script>
</body>
</html>