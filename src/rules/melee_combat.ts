import { Rule } from "./rule";
import type { TickContext } from "../core/tick_context";
import type { Unit } from "../types/Unit";
import type { QueuedCommand } from "../core/command_handler";

export class MeleeCombat extends Rule {
  private engagements: Map<string, string> = new Map();
  private lastAttacks: Map<string, number> = new Map();

  execute(context: TickContext): QueuedCommand[] {
    const commands: QueuedCommand[] = [];
    const currentTick = context.getCurrentTick();

    const arrays = context.getArrays();
    for (const i of arrays.activeIndices) {
      if (arrays.state[i] === 2) {
        const unitId = arrays.unitIds[i];
        const coldData = context.getUnitColdData(unitId);
        if (coldData?.meta?.lastAttacked) {
          const ticksSinceAttack = currentTick - coldData.meta.lastAttacked;
          if (ticksSinceAttack > 2) {
            commands.push({
              type: "meta",
              params: {
                unitId: unitId,
                state: "idle",
              },
            });
          }
        }
      }
    }

    // Clear engagements AFTER batcher processes, not before
    // this.engagements.clear(); // MOVED TO AFTER BATCHER PROCESSES
    
    // Try to use pairwise batcher if available
    const batcher = context.getPairwiseBatcher();
    if (batcher) {
      // Clear engagements just before registering
      this.engagements.clear();
      // Register intent - the batcher will handle the N^2 loop
      batcher.register(
        "MeleeCombat",
        (unitA: Unit, unitB: Unit) => {
          // Process melee combat between these two units
          return this.processCombatPair(unitA, unitB, context);
        },
        3.5, // Max range (hero range)
        (a: Unit, b: Unit) => {
          // Filter: different teams, alive, not engaged, not noncombatant
          if (a.team === b.team) return false;
          if (a.hp <= 0 || b.hp <= 0) return false;
          if (this.engagements.has(a.id) || this.engagements.has(b.id)) return false;
          if (a.tags?.includes("noncombatant") || b.tags?.includes("noncombatant")) return false;
          if (a.tags?.includes("effect") || b.tags?.includes("effect")) return false; // Don't attack effect units
          if (a.meta?.jumping || b.meta?.jumping) return false;
          return true;
        }
      );
      // Commands will be generated by the batcher
      return commands;
    }
    
    // Fallback if no batcher
    this.engagements.clear();
    this.performMeleeCombat(context, commands);
    return commands;
  }

  private processCombatPair(unitA: Unit, unitB: Unit, context: TickContext): any[] {
    const commands: QueuedCommand[] = [];
    
    // Skip if already engaged
    if (this.engagements.has(unitA.id) || this.engagements.has(unitB.id)) {
      return commands;
    }
    
    const dx = unitB.pos.x - unitA.pos.x;
    const dy = unitB.pos.y - unitA.pos.y;
    const distSq = dx * dx + dy * dy;
    
    const meleeRangeSq = 1.5 * 1.5;
    const heroRangeSq = 3.5 * 3.5;
    
    const isHeroA = unitA.tags?.includes("hero");
    const isHeroB = unitB.tags?.includes("hero");
    const currentTick = context.getCurrentTick();
    
    // Check both directions for hero attacks
    if (isHeroA && !unitA.meta?.controlled && distSq <= heroRangeSq) {
      const facing = unitA.meta?.facing || "right";
      let inCone = false;
      if (facing === "right" && dx >= -1) inCone = true;
      else if (facing === "left" && dx <= 1) inCone = true;
      
      if (inCone) {
        const lastAttack = this.lastAttacks.get(unitA.id) || -100;
        if (currentTick - lastAttack >= 3) {
          this.lastAttacks.set(unitA.id, currentTick);
          this.engagements.set(unitA.id, unitB.id);
          
          commands.push({
            type: "strike",
            unitId: unitA.id,
            params: {
              targetId: unitB.id,
              damage: (unitA.dmg || 1) * 2,
              knockback: 3,
              aspect: "heroic",
            },
          });
          
          commands.push({
            type: "meta",
            params: {
              unitId: unitA.id,
              state: "attacking",
              meta: {
                lastAttacked: currentTick,
                attacking: true,
              },
            },
          });
        }
      }
    }
    
    // Check reverse for hero B
    if (isHeroB && !unitB.meta?.controlled && distSq <= heroRangeSq) {
      const facing = unitB.meta?.facing || "right";
      const dxRev = -dx; // Reverse direction
      const dyRev = -dy;
      let inCone = false;
      if (facing === "right" && dxRev >= -1) inCone = true;
      else if (facing === "left" && dxRev <= 1) inCone = true;
      
      if (inCone && !this.engagements.has(unitB.id)) {
        const lastAttack = this.lastAttacks.get(unitB.id) || -100;
        if (currentTick - lastAttack >= 3) {
          this.lastAttacks.set(unitB.id, currentTick);
          this.engagements.set(unitB.id, unitA.id);
          
          commands.push({
            type: "strike",
            unitId: unitB.id,
            params: {
              targetId: unitA.id,
              damage: (unitB.dmg || 1) * 2,
              knockback: 3,
              aspect: "heroic",
            },
          });
          
          commands.push({
            type: "meta",
            params: {
              unitId: unitB.id,
              state: "attacking",
              meta: {
                lastAttacked: currentTick,
                attacking: true,
              },
            },
          });
        }
      }
    }
    
    // Regular melee if not heroes and not already engaged
    if (!isHeroA && !isHeroB && distSq <= meleeRangeSq && !this.engagements.has(unitA.id) && !this.engagements.has(unitB.id)) {
      this.engagements.set(unitA.id, unitB.id);
      this.engagements.set(unitB.id, unitA.id);
      
      const lastAttackA = this.lastAttacks.get(unitA.id) || -100;
      const lastAttackB = this.lastAttacks.get(unitB.id) || -100;
      
      if (currentTick - lastAttackA >= 5) {
        this.registerHit(unitA.id, unitB.id, unitA.dmg || 1, context, commands);
      }
      
      if (currentTick - lastAttackB >= 5) {
        this.registerHit(unitB.id, unitA.id, unitB.dmg || 1, context, commands);
      }
    }
    
    return commands;
  }

  private performMeleeCombat(
    context: TickContext,
    commands: QueuedCommand[],
  ): void {
    const meleeRange = 1.5;
    const meleeRangeSq = meleeRange * meleeRange;
    const heroRange = 3.5; // Much wider range for hero
    const heroRangeSq = heroRange * heroRange;

    const arrays = (context as any).sim?.unitArrays;
    const coldData = (context as any).sim?.unitColdData;

    if (arrays && coldData) {
      const activeIndices = arrays.activeIndices;
      const count = activeIndices.length;

      for (let i = 0; i < count; i++) {
        const idxA = activeIndices[i];

        if (arrays.state[idxA] === 3 || arrays.hp[idxA] <= 0) continue;
        const attackerId = arrays.unitIds[idxA];
        if (this.engagements.has(attackerId)) continue;

        const coldA = coldData.get(attackerId);
        if (coldA?.meta?.jumping || coldA?.tags?.includes("noncombatant") || coldA?.tags?.includes("effect"))
          continue;

        const x1 = arrays.posX[idxA];
        const y1 = arrays.posY[idxA];
        const team1 = arrays.team[idxA];
        const isHero = coldA?.tags?.includes("hero");
        const isControlled = coldA?.meta?.controlled;

        let heroAlreadyAttacked = false;

        if (isHero && !isControlled) {
          const facing = coldA?.meta?.facing || "right";
          const currentTick = context.getCurrentTick();
          const attackerLastAttack = this.lastAttacks.get(attackerId) || -100;
          // Auto-controlled heroes have some cooldown
          const attackCooldown = 3;

          if (currentTick - attackerLastAttack >= attackCooldown) {
            this.lastAttacks.set(attackerId, currentTick);

            for (let j = 0; j < count; j++) {
              const idxB = activeIndices[j];
              if (idxB === idxA) continue;
              if (arrays.state[idxB] === 3 || arrays.hp[idxB] <= 0) continue;
              if (team1 === arrays.team[idxB]) continue;
              
              // Don't attack neutral units unless we're hostile
              const team2 = arrays.team[idxB];
              if (team1 !== 2 && team2 === 1) continue; // Non-hostile shouldn't attack neutral

              const targetId = arrays.unitIds[idxB];
              const dx = arrays.posX[idxB] - x1;
              const dy = arrays.posY[idxB] - y1;
              const distSq = dx * dx + dy * dy;

              if (distSq > heroRangeSq) continue;

              let inCone = false;
              if (facing === "right" && dx >= -1)
                inCone = true; // Everything not directly behind
              else if (facing === "left" && dx <= 1) inCone = true;
              else if (facing === "up" && dy <= 1) inCone = true;
              else if (facing === "down" && dy >= -1) inCone = true;

              if (!inCone) continue;

              const coldB = coldData.get(targetId);
              if (coldB?.meta?.jumping || coldB?.tags?.includes("noncombatant") || coldB?.tags?.includes("effect"))
                continue;

              commands.push({
                type: "strike",
                unitId: attackerId,
                params: {
                  targetId: targetId,
                  damage: arrays.dmg[idxA] * 2, // Double damage for hero
                  knockback: 3, // Strong knockback
                  aspect: "heroic",
                },
              });
            }

            commands.push({
              type: "meta",
              params: {
                unitId: attackerId,
                state: "attacking",
                meta: {
                  lastAttacked: currentTick,
                  attacking: true,
                },
              },
            });

            heroAlreadyAttacked = true;
          }
        }

        if ((isHero && isControlled) || heroAlreadyAttacked) {
          continue;
        }

        for (let j = i + 1; j < count; j++) {
          const idxB = activeIndices[j];

          if (arrays.state[idxB] === 3 || arrays.hp[idxB] <= 0) continue;
          if (team1 === arrays.team[idxB]) continue;
          
          // Don't attack neutral units unless we're hostile
          const team2 = arrays.team[idxB];
          if (team1 !== 2 && team2 === 1) continue; // Non-hostile shouldn't attack neutral
          if (team2 !== 2 && team1 === 1) continue; // Neutral shouldn't attack non-hostile

          const targetId = arrays.unitIds[idxB];
          if (this.engagements.has(targetId)) continue;

          const dx = arrays.posX[idxB] - x1;
          const dy = arrays.posY[idxB] - y1;
          const distSq = dx * dx + dy * dy;

          if (distSq > meleeRangeSq) continue;

          const coldB = coldData.get(targetId);
          if (coldB?.meta?.jumping || coldB?.tags?.includes("noncombatant") || coldB?.tags?.includes("effect"))
            continue;

          this.engagements.set(attackerId, targetId);
          this.engagements.set(targetId, attackerId);

          const currentTick = context.getCurrentTick();
          const attackerLastAttack = this.lastAttacks.get(attackerId) || -100;
          const targetLastAttack = this.lastAttacks.get(targetId) || -100;
          // Regular units need some cooldown to prevent instant kills
          const attackCooldown = 5;

          const attackerCanAttack =
            currentTick - attackerLastAttack >= attackCooldown;
          const targetCanAttack =
            currentTick - targetLastAttack >= attackCooldown;

          if (attackerCanAttack) {
            this.registerHit(
              attackerId,
              targetId,
              arrays.dmg[idxA] || 1,
              context,
              commands,
            );
          }

          if (targetCanAttack && attackerCanAttack) {
            if (idxA < idxB) {
            } else {
              this.registerHit(
                targetId,
                attackerId,
                arrays.dmg[idxB] || 1,
                context,
                commands,
              );
            }
          } else if (targetCanAttack && !attackerCanAttack) {
            this.registerHit(
              targetId,
              attackerId,
              arrays.dmg[idxB] || 1,
              context,
              commands,
            );
          }

          break; // Each unit only engages one target
        }
      }
    } else {
      const allUnits = context.getAllUnits();
      for (const attacker of allUnits) {
        if (this.engagements.has(attacker.id)) continue;

        if (attacker.hp <= 0) continue;
        if (attacker.meta?.jumping) continue;
        if (attacker.tags?.includes("noncombatant")) continue;

        const nearbyUnits = context.findUnitsInRadius(attacker.pos, meleeRange);

        for (const target of nearbyUnits) {
          if (target.id === attacker.id) continue;

          if (target.hp <= 0) continue;
          if (target.meta?.jumping) continue;
          if (target.tags?.includes("noncombatant")) continue;

          if (attacker.team === target.team) continue;

          this.processHit(context, attacker, target, commands);
          break;
        }
      }
    }
  }

  private registerHit(
    attackerId: string,
    targetId: string,
    damage: number,
    context: TickContext,
    commands: QueuedCommand[],
  ): void {
    this.lastAttacks.set(attackerId, context.getCurrentTick());

    commands.push({
      type: "halt",
      params: { unitId: attackerId },
    });

    commands.push({
      type: "meta",
      params: {
        unitId: attackerId,
        meta: { lastAttacked: context.getCurrentTick() },
        state: "attack",
      },
    });

    commands.push({
      type: "damage",
      params: {
        targetId: targetId,
        amount: damage,
        aspect: "physical",
        sourceId: attackerId,
      },
    });
  }

  private processHit(
    context: TickContext,
    attacker: Unit,
    target: Unit,
    commands: QueuedCommand[],
  ): void {
    if (attacker.hp <= 0 || target.hp <= 0) return;
    this.registerHit(
      attacker.id,
      target.id,
      attacker.dmg || 1,
      context,
      commands,
    );
  }
}